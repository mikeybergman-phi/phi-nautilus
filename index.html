<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nautilus — φ Modes + True Per-Turn Rise (φ ticks, 5 decimals)</title>
<style>
  :root{--uiw:clamp(260px,26vw,420px)}
  html,body{height:100%;margin:0;background:#0b0f14;color:#cfd5dd;font:13px ui-sans-serif,system-ui,-apple-system}
  #app{position:fixed;inset:0}
  .ui{
    position:fixed;top:12px;left:12px;display:grid;gap:10px;
    width:var(--uiw);
    background:rgba(10,13,18,.92);border:1px solid #1e2733;border-radius:12px;padding:12px
  }
  .row{display:flex;align-items:center;gap:8px}
  .row label{flex:1;color:#9fb1c7}
  .row input[type="range"]{flex:2}
  .row input[type="number"], .row select{
    width:120px;background:#0a0d12;color:#e7eaee;border:1px solid #2b3a4a;border-radius:8px;padding:6px
  }
  .badge{font-size:12px;opacity:.9;padding:2px 6px;border:1px solid #2b3a4a;border-radius:8px;white-space:nowrap}
  .row button{background:#122033;color:#e7eaee;border:1px solid #2b3a4a;border-radius:8px;padding:6px 10px;cursor:pointer}
  .row button:hover{background:#17283c}
  .hint{opacity:.8}
</style>
</head>
<body>
<div id="app"></div>

<div class="ui">
  <div class="row">
    <label>φ scaling mode</label>
    <select id="phiMode">
      <option value="phi_full">φ per full turn</option>
      <option value="phi_half">φ per 1/2 turn</option>
      <option value="phi_quarter">φ per 1/4 turn</option>
      <option value="custom">Custom W (per full turn)</option>
    </select>
    <span id="wBadge" class="badge">W ≈ φ</span>
  </div>

  <div class="row" id="customRow" style="display:none">
    <label>Custom W (per full turn)</label>
    <input id="W" type="range" min="1.05" max="8.0" step="0.00001" value="1.6180339887">
    <input id="W_val" type="number" step="0.00001" value="1.61803">
  </div>

  <div class="row">
    <label>Turns</label>
    <input id="turns" type="range" min="0.5" max="12" step="0.1" value="4.5">
    <input id="turns_val" type="number" step="0.1" value="4.5">
  </div>

  <!-- D0/A0 removed from UI; fixed internally to D0 = 1, A0 = φ^-3 -->

  <div class="row">
    <label>Rise per turn (units)</label>
    <input id="rise" type="range" min="-12" max="12" step="0.00001" value="0" list="phiTicks">
    <input id="rise_val" type="number" step="0.00001" min="-12" max="12" value="0.00000">
  </div>
  <!-- φ tick marks for easy picking (values shown to 5 decimals) -->
  <datalist id="phiTicks">
    <!-- Negative φ^k -->
    <option value="-11.09017" label="-φ^5"></option>
    <option value="-6.85410" label="-φ^4"></option>
    <option value="-4.23607" label="-φ^3"></option>
    <option value="-2.61803" label="-φ^2"></option>
    <option value="-1.61803" label="-φ^1"></option>
    <option value="-1.00000" label="-φ^0"></option>
    <option value="-0.61803" label="-φ^-1"></option>
    <option value="-0.38197" label="-φ^-2"></option>
    <option value="-0.23607" label="-φ^-3"></option>
    <option value="-0.14590" label="-φ^-4"></option>
    <option value="-0.09017" label="-φ^-5"></option>
    <!-- Zero -->
    <option value="0.00000" label="0"></option>
    <!-- Positive φ^k -->
    <option value="0.09017" label="φ^-5"></option>
    <option value="0.14590" label="φ^-4"></option>
    <option value="0.23607" label="φ^-3"></option>
    <option value="0.38197" label="φ^-2"></option>
    <option value="0.61803" label="φ^-1"></option>
    <option value="1.00000" label="φ^0"></option>
    <option value="1.61803" label="φ^1"></option>
    <option value="2.61803" label="φ^2"></option>
    <option value="4.23607" label="φ^3"></option>
    <option value="6.85410" label="φ^4"></option>
    <option value="11.09017" label="φ^5"></option>
  </datalist>

  <div class="row">
    <label></label>
    <span id="tBadge" class="badge">Δz (first turn) = 0.00000</span>
  </div>

  <div class="row">
    <label>Rainbow (per turn)</label><input id="rainbow" type="checkbox" checked>
    <label>Wireframe</label><input id="wire" type="checkbox">
    <label>Translucent</label><input id="trans" type="checkbox" checked>
  </div>
  <div class="row">
    <label>Opacity</label>
    <input id="opacity" type="range" min="0.08" max="1.0" step="0.01" value="0.35">
    <input id="opacity_val" type="number" step="0.01" value="0.35">
  </div>

  <div class="row">
    <button id="viewXY">View XY</button>
    <button id="viewISO">ISO</button>
    <button id="resetCam">Reset</button>
  </div>
  <div class="row hint">Tip: on Chrome/Edge, the slider shows tick marks at φ-levels; click near a tick, or type an exact value with 5 decimals.</div>
</div>

<!-- Import map -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { ParametricGeometry } from 'three/examples/jsm/geometries/ParametricGeometry.js';

const PHI = (1 + Math.sqrt(5)) / 2;

// ---- Fixed geometry (overlap-safe for W=φ) ----
const D0 = 1.0;                       // base centerline radius
const A0 = Math.pow(PHI, -3);         // aperture base = φ^-3 ≈ 0.2360679775

// ---- Fixed tessellation ----
const U_SEG = 320;                    // along the spiral
const V_SEG = 64;                     // around the aperture

// Scene
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setClearColor(0x0b0f14, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 100000);
const defaultCam = new THREE.Vector3(4.8, 2.8, 5.2);
camera.position.copy(defaultCam);
camera.lookAt(0,0,0);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0xffffff, 0.75));
const key = new THREE.DirectionalLight(0xffffff, 0.9); key.position.set(6,8,5); scene.add(key);
const rim = new THREE.DirectionalLight(0x8fb8ff, 0.35); rim.position.set(-6,-3,8); scene.add(rim);

const grid = new THREE.GridHelper(40, 40, 0x213040, 0x152233);
grid.position.y = -0.001;
scene.add(grid);

const root = new THREE.Group();
scene.add(root);

// Materials
let mat = new THREE.MeshStandardMaterial({
  color: 0xffffff, metalness: 0.0, roughness: 0.45,
  vertexColors: true, transparent: true, opacity: 0.35, side: THREE.DoubleSide
});
const matWire = new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true, transparent:true, opacity:0.15});

let meshObj=null, wireObj=null;

// UI helpers
const $ = id => document.getElementById(id);
const bind = (rangeId, numId, cb) => {
  const r = $(rangeId), n = $(numId);
  const sync = v => { r.value = v; n.value = v; cb(); };
  r.addEventListener('input', () => sync(r.value));
  n.addEventListener('input', () => sync(n.value));
};

// Per-turn growth W from φ mode
function effectiveW(){
  const mode = $('phiMode').value;
  if (mode === 'phi_full')    return PHI;             // φ per full turn
  if (mode === 'phi_half')    return PHI*PHI;         // φ per half-turn → per-turn W = φ^2
  if (mode === 'phi_quarter') return Math.pow(PHI,4); // φ per quarter-turn → per-turn W = φ^4
  return parseFloat($('W').value);                    // custom per-turn
}
function updateWBadge(){
  const W = effectiveW();
  $('wBadge').textContent = `W ≈ ${W.toFixed(5)} · W/φ ≈ ${(W/PHI).toFixed(5)}`;
  const customRow = document.getElementById('customRow');
  customRow.style.display = ($('phiMode').value === 'custom') ? 'flex' : 'none';
}

// Parametric shell surface (smooth) with true per-turn rise
function nautilusXYZ(u01, v01, target, params){
  const { turns, W, M } = params; // M = slider value = Δz of the first full turn

  const u0 = 1e-5;
  const u1 = turns * Math.PI * 2;
  const u = u0 + (u1 - u0) * u01;
  const v = v01 * Math.PI * 2;

  // per-radian growth so 2π → W
  const k = Math.log(W) / (2*Math.PI);
  const s = Math.exp(k * u);       // global scale at angle u

  const R = D0 * s;                // centerline radius
  const a = A0 * s;                // aperture radius

  // True per-turn rise:
  // T(u) = M * (s(u) - 1) / (W - 1)
  let T;
  if (Math.abs(W - 1) < 1e-9) {
    T = (M / (2*Math.PI)) * u; // near-W=1 fallback
  } else {
    T = M * (s - 1) / (W - 1);
  }

  const rv = R + a * Math.cos(v);
  const x = rv * Math.cos(u);
  const y = rv * Math.sin(u);
  const z = T + a * Math.sin(v);

  target.set(x, y, z);
}

// Rainbow color per turn
function buildColorsPerTurn(geom, turns){
  const colors = new Float32Array((U_SEG+1)*(V_SEG+1)*3);
  const color = new THREE.Color();
  const cols = V_SEG+1;
  for (let iu=0; iu<=U_SEG; iu++){
    const h = ((iu/U_SEG)*turns) % 1; // hue cycles each revolution
    color.setHSL(h, 1.0, 0.5);
    for (let iv=0; iv<=V_SEG; iv++){
      const idx = (iu*cols + iv)*3;
      colors[idx]   = color.r;
      colors[idx+1] = color.g;
      colors[idx+2] = color.b;
    }
  }
  geom.setAttribute('color', new THREE.BufferAttribute(colors,3));
}

// Camera fit
function autoFitCameraToRadius(R){
  const far = Math.min(1e6, Math.max(500, R*6));
  camera.far = far;
  camera.near = Math.max(0.01, far/10000);
  camera.updateProjectionMatrix();
  const targetDist = Math.max(6.0, R*2.2);
  const dir = camera.position.clone().normalize();
  if (!isFinite(dir.length()) || dir.length()===0) camera.position.set(4.8,2.8,5.2);
  camera.position.copy(camera.position.clone().normalize().multiplyScalar(targetDist));
  controls.target.set(0,0,0);
  controls.update();
}

function buildShell(){
  const W      = effectiveW();
  const turns  = parseFloat($('turns').value);
  const M      = parseFloat($('rise').value); // Δz of the first full turn
  $('rise_val').value = M.toFixed(5);
  $('tBadge').textContent = `Δz (first turn) = ${M.toFixed(5)}`;

  const rainbow= $('rainbow').checked;
  const showWire = $('wire').checked;
  const translucent = $('trans').checked;
  const opacity = parseFloat($('opacity').value);

  if (meshObj){ root.remove(meshObj); meshObj.geometry.dispose(); meshObj=null; }
  if (wireObj){ root.remove(wireObj); wireObj.geometry.dispose(); wireObj=null; }

  const params = { turns, W, M };
  const geom = new ParametricGeometry((u,v,t)=>nautilusXYZ(u,v,t,params), U_SEG, V_SEG);
  geom.computeVertexNormals();

  if (rainbow) buildColorsPerTurn(geom, turns);
  else {
    const n = geom.attributes.position.count;
    const colors = new Float32Array(n*3);
    for (let i=0;i<colors.length;i+=3){ colors[i]=1; colors[i+1]=1; colors[i+2]=1; }
    geom.setAttribute('color', new THREE.BufferAttribute(colors,3));
  }

  meshObj = new THREE.Mesh(geom, mat);
  mat.transparent = translucent;
  mat.opacity = opacity;
  root.add(meshObj);

  wireObj = new THREE.Mesh(geom.clone(), matWire);
  wireObj.visible = showWire;
  root.add(wireObj);

  geom.computeBoundingSphere();
  const R = geom.boundingSphere ? Math.max(geom.boundingSphere.radius, 1.0) : 5.0;
  autoFitCameraToRadius(R);

  updateWBadge();
  controls.update();
}

// Bindings
['phiMode'].forEach(id => $(id).addEventListener('change', ()=>{updateWBadge(); buildShell();}));
['W','turns','opacity','rise'].forEach(id => bind(id, id+'_val', buildShell));
['wire','trans','rainbow'].forEach(id => $(id).addEventListener('change', buildShell));

$('viewXY').onclick = () => { camera.position.set(0,0,6.5); camera.lookAt(0,0,0); controls.update(); };
$('viewISO').onclick = () => { camera.position.set(6,4,6); camera.lookAt(0,0,0); controls.update(); };
$('resetCam').onclick = () => { camera.position.copy(defaultCam); camera.lookAt(0,0,0); controls.update(); };

updateWBadge();
buildShell();

// Resize + animate
addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
(function loop(){
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
